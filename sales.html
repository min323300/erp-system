// ==========================================
// ERP Lite v18 - 면세 처리 + 업체별단가 조회
// 2026.02.19 - taxType 필드 추가, getCustomPrices 추가
// 2026.02.19 - addSale 시 입금액 > 0 이면 입금관리 자동 기록
// ==========================================

const ss = SpreadsheetApp.getActiveSpreadsheet();

const SHEETS = {
  myCompany: '자기회사정보',
  sales: '판매거래',
  payments: '입금관리',
  purchases: '입고거래',
  supplierPayments: '지급관리',
  inventory: '재고현황',
  companies: '업체관리',
  items: '품목관리',
  monthly: '월별집계',
  statement: '거래명세표',
  customPrices: '거래처별가격'
};

// ==========================================
// 메인 핸들러
// ==========================================

function doGet(e) { return handleRequest(e); }
function doPost(e) { return handleRequest(e); }

function handleRequest(e) {
  try {
    const params = e.parameter || {};
    const action = params.action;
    let data = {};
    if (params.data) {
      try { data = JSON.parse(params.data); } catch(err) { data = params; }
    } else { data = params; }
    
    let result;
    switch (action) {
      case 'getMyCompany': result = getMyCompany(); break;
      case 'saveMyCompany': result = saveMyCompany(data); break;
      case 'getSales': result = getSales(params); break;
      case 'addSale': result = addSale(data); break;
      case 'getLastPrice': result = getLastPrice(params.company, params.item); break;
      case 'getCustomPrices': result = getCustomPrices(params.company); break;
      case 'saveCustomPrice': result = saveCustomPrice(data); break;
      case 'getPayments': result = getPayments(params); break;
      case 'addPayment': result = addPayment(data); break;
      case 'getCompanies': result = getCompanies(params.type); break;
      case 'addCompany': result = addCompany(data); break;
      case 'getItems': result = getItems(); break;
      case 'addItem': result = addItem(data); break;
      case 'generateStatement':
        if (params.date && params.customer) {
          result = generateStatementByDateAndCustomer(params.date, params.customer);
        } else if (params.saleIndex) {
          result = generateStatement(params.saleIndex);
        } else {
          result = { success: false, message: '날짜와 거래처 또는 판매 인덱스가 필요합니다.' };
        }
        break;
      case 'getPurchases': result = getPurchases(params); break;
      case 'addPurchase': result = addPurchase(data); break;
      case 'getSupplierPayments': result = getSupplierPayments(params); break;
      case 'addSupplierPayment': result = addSupplierPayment(data); break;
      case 'getInventory': result = getInventory(); break;
      case 'getMonthlyReport': result = getMonthlyReport(params.year, params.month); break;
      case 'getYearlyReport': result = getYearlyReport(params.year); break;
      case 'getProfitLoss': result = getProfitLoss(params.startDate, params.endDate); break;
      case 'getDashboard': result = getDashboard(); break;
      default: result = { success: false, message: '알 수 없는 요청: ' + action };
    }
    return createResponse(result);
  } catch (error) {
    Logger.log('에러: ' + error.toString());
    return createResponse({ success: false, message: '서버 오류: ' + error.toString() });
  }
}

function createResponse(data) {
  return ContentService.createTextOutput(JSON.stringify(data)).setMimeType(ContentService.MimeType.JSON);
}

// ==========================================
// 회사 정보
// ==========================================

function getMyCompany() {
  try {
    const sheet = ss.getSheetByName(SHEETS.myCompany);
    if (!sheet) return { success: false, message: '자기회사정보 시트를 찾을 수 없습니다.' };
    const data = sheet.getRange(2, 1, 1, 7).getValues()[0];
    return { success: true, data: {
      name: data[0]||'', businessNumber: data[1]||'', ceo: data[2]||'',
      address: data[3]||'', phone: data[4]||'', email: data[5]||'', bankAccount: data[6]||''
    }};
  } catch (error) { return { success: false, message: '회사 정보 조회 실패: ' + error.toString() }; }
}

function saveMyCompany(data) {
  try {
    const sheet = ss.getSheetByName(SHEETS.myCompany);
    sheet.getRange(2, 1, 1, 7).setValues([[
      data.name||'', data.businessNumber||'', data.ceo||'',
      data.address||'', data.phone||'', data.email||'', data.bankAccount||''
    ]]);
    return { success: true, message: '회사 정보가 저장되었습니다.' };
  } catch (error) { return { success: false, message: '저장 실패: ' + error.toString() }; }
}

// ==========================================
// 판매 관리
// ==========================================

function getSales(params) {
  try {
    const sheet = ss.getSheetByName(SHEETS.sales);
    const lastRow = sheet.getLastRow();
    if (lastRow < 2) return { success: true, data: [] };
    
    const data = sheet.getRange(2, 1, lastRow - 1, 15).getValues();
    
    const companyReceivables = {};
    data.forEach(row => {
      companyReceivables[row[1]] = (companyReceivables[row[1]] || 0) + (Number(row[10]) || 0);
    });
    
    const sales = data.map((row, index) => ({
      index, date: row[0], customer: row[1], company: row[1],
      item: row[2], quantity: Number(row[3])||0, price: Number(row[4])||0,
      supplyPrice: Number(row[5])||0, vat: Number(row[6])||0, total: Number(row[7])||0,
      paymentStatus: row[8]||'미입금', paid: row[8]||'미입금',
      paymentAmount: Number(row[9])||0, paidAmount: Number(row[9])||0,
      unpaid: Number(row[10])||0, receivable: Number(row[10])||0,
      delivery: row[11]||'', deliveryMethod: row[11]||'',
      traceNumber: row[12]||'', boxReturn: row[13]||'미회수',
      taxType: row[14]||'과세',
      companyTotalReceivable: companyReceivables[row[1]] || 0
    }));
    
    let filtered = sales;
    if (params.company || params.customer) {
      const t = params.company || params.customer;
      filtered = filtered.filter(s => s.company === t);
    }
    if (params.startDate) filtered = filtered.filter(s => new Date(s.date) >= new Date(params.startDate));
    if (params.endDate) filtered = filtered.filter(s => new Date(s.date) <= new Date(params.endDate));
    
    return { success: true, data: filtered };
  } catch (error) { return { success: false, message: '판매 내역 조회 실패: ' + error.toString() }; }
}

// ==========================================
// ✅ addSale - 판매 등록 + 입금관리 자동 연동
// 판매 등록 시 입금액이 있으면 입금관리 시트에 자동 기록
// ==========================================

function addSale(data) {
  try {
    const sheet = ss.getSheetByName(SHEETS.sales);
    const customer = data.customer || data.company || '';
    const deliveryMethod = data.delivery || data.deliveryMethod || '';
    const paymentStatus = data.paymentStatus || data.paid || '미입금';
    const paymentAmount = Number(data.paymentAmount || data.paidAmount || 0);
    const unpaid = Number(data.unpaid || data.receivable || 0);
    const taxType = data.taxType || '과세';
    const saleDate = data.date || '';

    // 판매거래 시트 저장
    sheet.appendRow([
      saleDate, customer, data.item||'',
      Number(data.quantity)||0, Number(data.price)||0,
      Number(data.supplyPrice)||0, Number(data.vat)||0, Number(data.total)||0,
      paymentStatus, paymentAmount, unpaid,
      deliveryMethod, data.traceNumber||'', data.boxReturn||'미회수', taxType
    ]);

    // ✅ 입금액 > 0 이면 입금관리 시트에도 자동 기록
    if (paymentAmount > 0) {
      _autoRecordPayment(saleDate, customer, paymentAmount, data.item || '');
    }

    return { success: true, message: '판매가 등록되었습니다.' };
  } catch (error) { return { success: false, message: '판매 등록 실패: ' + error.toString() }; }
}

// ==========================================
// ✅ 내부 함수: 입금관리 자동 기록
// 같은 날짜+거래처가 이미 있으면 금액 누적, 없으면 신규 추가
// ==========================================

function _autoRecordPayment(date, customer, amount, itemName) {
  try {
    const paymentSheet = ss.getSheetByName(SHEETS.payments);
    if (!paymentSheet) return;

    const lastRow = paymentSheet.getLastRow();
    const formattedDate = Utilities.formatDate(new Date(date), 'GMT+9', 'yyyy-MM-dd');

    // 같은 날짜+거래처 행이 이미 있으면 금액 누적
    if (lastRow >= 2) {
      const existingData = paymentSheet.getRange(2, 1, lastRow - 1, 5).getValues();
      for (let i = 0; i < existingData.length; i++) {
        const rowDate = Utilities.formatDate(new Date(existingData[i][0]), 'GMT+9', 'yyyy-MM-dd');
        if (rowDate === formattedDate && existingData[i][1] === customer && existingData[i][3] === '판매등록') {
          // 금액 누적
          paymentSheet.getRange(i + 2, 3).setValue((Number(existingData[i][2]) || 0) + amount);
          // 비고에 품목 추가
          const currentNote = existingData[i][4] || '';
          paymentSheet.getRange(i + 2, 5).setValue(currentNote ? currentNote + ', ' + itemName : '판매등록: ' + itemName);
          return;
        }
      }
    }

    // 없으면 신규 행 추가
    paymentSheet.appendRow([date, customer, amount, '판매등록', '판매등록: ' + itemName]);

  } catch (error) {
    Logger.log('입금관리 자동 기록 실패: ' + error.toString());
  }
}

// ==========================================
// 거래처별 단가 조회
// ==========================================

function getCustomPrices(company) {
  try {
    if (!company) return { success: false, message: '거래처명이 필요합니다.' };
    
    const customPriceSheet = ss.getSheetByName(SHEETS.customPrices);
    const itemsSheet = ss.getSheetByName(SHEETS.items);
    const itemsLastRow = itemsSheet.getLastRow();
    const allItems = [];
    
    if (itemsLastRow >= 2) {
      itemsSheet.getRange(2, 1, itemsLastRow - 1, 3).getValues().forEach(row => {
        allItems.push({ name: row[0], defaultPrice: Number(row[2])||0, customPrice: null, source: 'default' });
      });
    }
    
    if (customPriceSheet) {
      const customLastRow = customPriceSheet.getLastRow();
      if (customLastRow >= 2) {
        customPriceSheet.getRange(2, 1, customLastRow - 1, 3).getValues().forEach(row => {
          if (row[0] === company) {
            const t = allItems.find(i => i.name === row[1]);
            if (t) { t.customPrice = Number(row[2])||0; t.source = 'custom'; }
          }
        });
      }
    }
    
    return { success: true, company, data: allItems.map(item => ({
      name: item.name,
      price: item.customPrice !== null ? item.customPrice : item.defaultPrice,
      defaultPrice: item.defaultPrice, customPrice: item.customPrice, source: item.source
    }))};
  } catch (error) { return { success: false, message: '거래처별 단가 조회 실패: ' + error.toString() }; }
}

function saveCustomPrice(data) {
  try {
    const company = data.company||'', item = data.item||'', price = Number(data.price)||0;
    if (!company || !item) return { success: false, message: '거래처명과 품목명이 필요합니다.' };
    
    const sheet = ss.getSheetByName(SHEETS.customPrices);
    if (!sheet) return { success: false, message: '거래처별가격 시트를 찾을 수 없습니다.' };
    
    const lastRow = sheet.getLastRow();
    if (lastRow >= 2) {
      const existingData = sheet.getRange(2, 1, lastRow - 1, 3).getValues();
      for (let i = 0; i < existingData.length; i++) {
        if (existingData[i][0] === company && existingData[i][1] === item) {
          sheet.getRange(i + 2, 3).setValue(price);
          return { success: true, message: `${company} - ${item} 단가가 수정되었습니다.` };
        }
      }
    }
    sheet.appendRow([company, item, price]);
    return { success: true, message: `${company} - ${item} 단가가 등록되었습니다.` };
  } catch (error) { return { success: false, message: '단가 저장 실패: ' + error.toString() }; }
}

function getLastPrice(company, item) {
  try {
    const customPriceSheet = ss.getSheetByName(SHEETS.customPrices);
    if (customPriceSheet && customPriceSheet.getLastRow() >= 2) {
      const data = customPriceSheet.getRange(2, 1, customPriceSheet.getLastRow() - 1, 3).getValues();
      for (let i = 0; i < data.length; i++) {
        if (data[i][0] === company && data[i][1] === item)
          return { success: true, data: { price: Number(data[i][2])||0, source: 'custom' } };
      }
    }
    const salesSheet = ss.getSheetByName(SHEETS.sales);
    if (salesSheet.getLastRow() >= 2) {
      const data = salesSheet.getRange(2, 1, salesSheet.getLastRow() - 1, 5).getValues();
      for (let i = data.length - 1; i >= 0; i--) {
        if (data[i][1] === company && data[i][2] === item)
          return { success: true, data: { price: Number(data[i][4])||0, source: 'recent' } };
      }
    }
    const itemsSheet = ss.getSheetByName(SHEETS.items);
    if (itemsSheet.getLastRow() >= 2) {
      const data = itemsSheet.getRange(2, 1, itemsSheet.getLastRow() - 1, 3).getValues();
      for (let i = 0; i < data.length; i++) {
        if (data[i][0] === item)
          return { success: true, data: { price: Number(data[i][2])||0, source: 'default' } };
      }
    }
    return { success: false, data: {} };
  } catch (error) { return { success: false, message: '가격 조회 실패: ' + error.toString() }; }
}

// ==========================================
// 입금 관리
// ==========================================

function getPayments(params) {
  try {
    const sheet = ss.getSheetByName(SHEETS.payments);
    const lastRow = sheet.getLastRow();
    if (lastRow < 2) return { success: true, data: [] };
    
    let payments = sheet.getRange(2, 1, lastRow - 1, 5).getValues().map(row => ({
      date: row[0], company: row[1], amount: Number(row[2])||0, method: row[3]||'', note: row[4]||''
    }));
    
    if (params.company) payments = payments.filter(p => p.company === params.company);
    if (params.startDate) payments = payments.filter(p => new Date(p.date) >= new Date(params.startDate));
    if (params.endDate) payments = payments.filter(p => new Date(p.date) <= new Date(params.endDate));
    
    return { success: true, data: payments };
  } catch (error) { return { success: false, message: '입금 내역 조회 실패: ' + error.toString() }; }
}

function addPayment(data) {
  try {
    const paymentSheet = ss.getSheetByName(SHEETS.payments);
    paymentSheet.appendRow([data.date||'', data.company||'', Number(data.amount)||0, data.method||'', data.note||'']);
    updateReceivables(data.company, Number(data.amount)||0);
    return { success: true, message: '입금이 등록되었습니다.' };
  } catch (error) { return { success: false, message: '입금 등록 실패: ' + error.toString() }; }
}

function updateReceivables(company, paymentAmount) {
  const sheet = ss.getSheetByName(SHEETS.sales);
  const lastRow = sheet.getLastRow();
  if (lastRow < 2) return;
  
  const data = sheet.getRange(2, 1, lastRow - 1, 12).getValues();
  let remaining = paymentAmount;
  
  for (let i = 0; i < data.length; i++) {
    if (data[i][1] === company && data[i][10] > 0 && remaining > 0) {
      const curr = Number(data[i][10])||0;
      const ded = Math.min(curr, remaining);
      sheet.getRange(i+2, 11).setValue(curr - ded);
      sheet.getRange(i+2, 10).setValue((Number(data[i][9])||0) + ded);
      sheet.getRange(i+2, 9).setValue(curr - ded === 0 ? '입금완료' : '부분입금');
      remaining -= ded;
    }
  }
}

// ==========================================
// 업체 관리
// ==========================================

function getCompanies(type) {
  try {
    const sheet = ss.getSheetByName(SHEETS.companies);
    const lastRow = sheet.getLastRow();
    if (lastRow < 2) return { success: true, data: [] };
    
    let companies = sheet.getRange(2, 1, lastRow - 1, 6).getValues().map(row => ({
      name: row[0]||'', type: row[1]||'', businessNumber: row[2]||'',
      ceo: row[3]||'', phone: row[4]||'', address: row[5]||''
    }));
    if (type) companies = companies.filter(c => c.type === type);
    return { success: true, data: companies };
  } catch (error) { return { success: false, message: '업체 조회 실패: ' + error.toString() }; }
}

function addCompany(data) {
  try {
    ss.getSheetByName(SHEETS.companies).appendRow([
      data.name||'', data.type||'', data.businessNumber||'',
      data.ceo||'', data.phone||'', data.address||''
    ]);
    return { success: true, message: '업체가 등록되었습니다.' };
  } catch (error) { return { success: false, message: '업체 등록 실패: ' + error.toString() }; }
}

// ==========================================
// 품목 관리
// ==========================================

function getItems() {
  try {
    const sheet = ss.getSheetByName(SHEETS.items);
    const lastRow = sheet.getLastRow();
    if (lastRow < 2) return { success: true, data: [] };
    return { success: true, data: sheet.getRange(2, 1, lastRow - 1, 5).getValues().map(row => ({
      name: row[0]||'', unit: row[1]||'', price: Number(row[2])||0,
      boxUnit: Number(row[3])||1, note: row[4]||''
    }))};
  } catch (error) { return { success: false, message: '품목 조회 실패: ' + error.toString() }; }
}

function addItem(data) {
  try {
    ss.getSheetByName(SHEETS.items).appendRow([
      data.name||'', data.unit||'', Number(data.price)||0, Number(data.boxUnit)||1, data.note||''
    ]);
    return { success: true, message: '품목이 등록되었습니다.' };
  } catch (error) { return { success: false, message: '품목 등록 실패: ' + error.toString() }; }
}

// ==========================================
// 거래명세표 생성 v18
// ==========================================

function generateStatementByDateAndCustomer(targetDate, targetCustomer) {
  try {
    const salesSheet = ss.getSheetByName(SHEETS.sales);
    const statementSheet = ss.getSheetByName(SHEETS.statement);
    const myCompanySheet = ss.getSheetByName(SHEETS.myCompany);
    const companiesSheet = ss.getSheetByName(SHEETS.companies);
    
    const allSalesData = salesSheet.getRange(2, 1, salesSheet.getLastRow() - 1, 15).getValues();
    const sameDaySales = allSalesData.filter(row => {
      const rowDate = Utilities.formatDate(new Date(row[0]), 'GMT+9', 'yyyy-MM-dd');
      return rowDate === targetDate && row[1] === targetCustomer;
    });
    
    if (sameDaySales.length === 0) return { success: false, message: '해당 날짜와 거래처의 판매 내역이 없습니다.' };
    
    const myCompany = myCompanySheet.getRange(2, 1, 1, 7).getValues()[0];
    const lastRow = companiesSheet.getLastRow();
    let clientCompany = [];
    if (lastRow >= 2) {
      clientCompany = companiesSheet.getRange(2, 1, lastRow-1, 6).getValues().find(c => c[0] === targetCustomer) || [];
    }
    
    let dayTotal = 0, dayReceivable = 0;
    sameDaySales.forEach(row => {
      dayTotal += (Number(row[7])||0) * (Number(row[3])||0);
      dayReceivable += (Number(row[10])||0) * (Number(row[3])||0);
    });
    
    statementSheet.clear();
    statementSheet.setColumnWidth(1, 80); statementSheet.setColumnWidth(2, 100);
    statementSheet.setColumnWidth(3, 150); statementSheet.setColumnWidth(4, 80);
    statementSheet.setColumnWidth(5, 100); statementSheet.setColumnWidth(6, 100);
    statementSheet.setColumnWidth(7, 100);
    
    let currentRow = 1;
    
    for (let copy = 0; copy < 2; copy++) {
      const copyLabel = copy === 0 ? '공급자 보관용' : '공급받는자 보관용';
      
      // 제목
      statementSheet.getRange(`A${currentRow}:G${currentRow}`).merge();
      statementSheet.getRange(`A${currentRow}`).setValue('거 래 명 세 표')
        .setFontSize(22).setFontWeight('bold').setHorizontalAlignment('center')
        .setVerticalAlignment('middle').setBackground('#4A86E8').setFontColor('#FFFFFF');
      statementSheet.setRowHeight(currentRow, 45); currentRow++;
      
      statementSheet.getRange(`A${currentRow}:G${currentRow}`).merge();
      statementSheet.getRange(`A${currentRow}`).setValue(`(${copyLabel})`)
        .setFontSize(11).setFontWeight('bold').setHorizontalAlignment('center').setFontColor('#1976d2');
      statementSheet.setRowHeight(currentRow, 25); currentRow++;
      
      statementSheet.getRange(`A${currentRow}:G${currentRow}`).merge();
      statementSheet.getRange(`A${currentRow}`)
        .setValue('발행일: ' + Utilities.formatDate(new Date(sameDaySales[0][0]), 'GMT+9', 'yyyy년 MM월 dd일'))
        .setHorizontalAlignment('right').setFontSize(10).setFontColor('#666666');
      statementSheet.setRowHeight(currentRow, 25); currentRow++;
      statementSheet.setRowHeight(currentRow, 5); currentRow++;
      
      const issuerStartRow = currentRow;
      statementSheet.getRange(`A${currentRow}`).setValue('【 발행자 】').setFontWeight('bold').setFontSize(11).setBackground('#E8F4F8'); currentRow++;
      statementSheet.getRange(`A${currentRow}`).setValue('회사명');
      statementSheet.getRange(`B${currentRow}:C${currentRow}`).merge();
      statementSheet.getRange(`B${currentRow}`).setValue(myCompany[0]); currentRow++;
      statementSheet.getRange(`A${currentRow}`).setValue('대표자');
      statementSheet.getRange(`B${currentRow}:C${currentRow}`).merge();
      statementSheet.getRange(`B${currentRow}`).setValue(myCompany[2]); currentRow++;
      statementSheet.getRange(`A${currentRow}`).setValue('사업자번호');
      statementSheet.getRange(`B${currentRow}:C${currentRow}`).merge();
      statementSheet.getRange(`B${currentRow}`).setValue(myCompany[1]); currentRow++;
      statementSheet.getRange(`A${currentRow}`).setValue('주소');
      statementSheet.getRange(`B${currentRow}:C${currentRow}`).merge();
      statementSheet.getRange(`B${currentRow}`).setValue(myCompany[3]); currentRow++;
      statementSheet.getRange(`A${currentRow}`).setValue('전화');
      statementSheet.getRange(`B${currentRow}:C${currentRow}`).merge();
      statementSheet.getRange(`B${currentRow}`).setValue(myCompany[4]); currentRow++;
      statementSheet.getRange(`A${currentRow}`).setValue('계좌번호');
      statementSheet.getRange(`B${currentRow}:C${currentRow}`).merge();
      statementSheet.getRange(`B${currentRow}`).setValue(myCompany[6]||'').setFontWeight('bold').setFontColor('#1976d2');
      const issuerEndRow = currentRow; currentRow++;
      
      for (let r = issuerStartRow+1; r <= issuerEndRow; r++) {
        statementSheet.getRange(`A${r}`).setBackground('#F3F3F3').setFontWeight('bold').setHorizontalAlignment('center');
      }
      
      let clientRow = issuerStartRow;
      statementSheet.getRange(`D${clientRow}`).setValue('【 거래처 】').setFontWeight('bold').setFontSize(11).setBackground('#E8F4F8'); clientRow++;
      statementSheet.getRange(`D${clientRow}`).setValue('회사명');
      statementSheet.getRange(`E${clientRow}:G${clientRow}`).merge();
      statementSheet.getRange(`E${clientRow}`).setValue(targetCustomer); clientRow++;
      
      if (clientCompany.length > 0) {
        statementSheet.getRange(`D${clientRow}`).setValue('대표자');
        statementSheet.getRange(`E${clientRow}:G${clientRow}`).merge();
        statementSheet.getRange(`E${clientRow}`).setValue(clientCompany[3]); clientRow++;
        statementSheet.getRange(`D${clientRow}`).setValue('사업자번호');
        statementSheet.getRange(`E${clientRow}:G${clientRow}`).merge();
        statementSheet.getRange(`E${clientRow}`).setValue(clientCompany[2]); clientRow++;
        statementSheet.getRange(`D${clientRow}`).setValue('주소');
        statementSheet.getRange(`E${clientRow}:G${clientRow}`).merge();
        statementSheet.getRange(`E${clientRow}`).setValue(clientCompany[5]); clientRow++;
        statementSheet.getRange(`D${clientRow}`).setValue('전화');
        statementSheet.getRange(`E${clientRow}:G${clientRow}`).merge();
        statementSheet.getRange(`E${clientRow}`).setValue(clientCompany[4]); clientRow++;
      }
      
      for (let r = issuerStartRow+1; r <= clientRow; r++) {
        statementSheet.getRange(`D${r}`).setBackground('#F3F3F3').setFontWeight('bold').setHorizontalAlignment('center');
      }
      
      statementSheet.getRange(`A${issuerStartRow}:C${issuerEndRow}`).setBorder(true,true,true,true,true,true,'#CCCCCC',SpreadsheetApp.BorderStyle.SOLID);
      statementSheet.getRange(`D${issuerStartRow}:G${clientRow}`).setBorder(true,true,true,true,true,true,'#CCCCCC',SpreadsheetApp.BorderStyle.SOLID);
      
      currentRow = Math.max(currentRow, clientRow + 1);
      statementSheet.setRowHeight(currentRow, 10); currentRow++;
      
      // 테이블 헤더
      statementSheet.getRange(`A${currentRow}:G${currentRow}`).setValues([['No.','이력번호','품목','수량','단가','공급가','부가세']]);
      statementSheet.getRange(`A${currentRow}:G${currentRow}`)
        .setBackground('#6FA8DC').setFontColor('#FFFFFF').setFontWeight('bold')
        .setHorizontalAlignment('center').setVerticalAlignment('middle');
      statementSheet.setRowHeight(currentRow, 30);
      const tableHeaderRow = currentRow; currentRow++;
      
      // 거래 내역
      sameDaySales.forEach((sale, index) => {
        const qty = Number(sale[3])||0;
        const unitPrice = Number(sale[4])||0;
        const unitSupply = Number(sale[5])||0;
        const unitVAT = Number(sale[6])||0;
        const taxType = sale[14]||'과세';
        
        const vatDisplay = taxType === '면세' ? '면세' : (unitVAT * qty).toLocaleString() + '원';
        const supplyDisplay = taxType === '면세'
          ? (unitPrice * qty).toLocaleString() + '원'
          : (unitSupply * qty).toLocaleString() + '원';
        
        statementSheet.getRange(currentRow, 1, 1, 7).setValues([[
          index+1, sale[12]||'', sale[2], qty+' 개',
          unitPrice.toLocaleString()+'원', supplyDisplay, vatDisplay
        ]]);
        statementSheet.getRange(currentRow, 1, 1, 7).setHorizontalAlignment('center');
        statementSheet.getRange(currentRow, 5, 1, 3).setHorizontalAlignment('right');
        if (taxType === '면세') {
          statementSheet.getRange(currentRow, 7).setBackground('#E8F5E9').setFontColor('#388E3C').setFontWeight('bold');
        }
        statementSheet.setRowHeight(currentRow, 25); currentRow++;
      });
      
      const tableEndRow = currentRow - 1;
      statementSheet.getRange(`A${tableHeaderRow}:G${tableEndRow}`).setBorder(true,true,true,true,true,true,'#000000',SpreadsheetApp.BorderStyle.SOLID);
      
      statementSheet.setRowHeight(currentRow, 8); currentRow++;
      
      // 합계
      statementSheet.getRange(`A${currentRow}:B${currentRow}`).merge();
      statementSheet.getRange(`A${currentRow}`).setValue('총 금액').setFontSize(13).setFontWeight('bold').setHorizontalAlignment('center').setBackground('#FFE599');
      statementSheet.getRange(`C${currentRow}:G${currentRow}`).merge();
      statementSheet.getRange(`C${currentRow}`).setValue(dayTotal.toLocaleString()+' 원').setFontSize(15).setFontWeight('bold').setHorizontalAlignment('right').setBackground('#FFF2CC');
      statementSheet.setRowHeight(currentRow, 35);
      statementSheet.getRange(`A${currentRow}:G${currentRow}`).setBorder(true,true,true,true,false,false,'#000000',SpreadsheetApp.BorderStyle.SOLID_MEDIUM);
      currentRow++;
      
      statementSheet.setRowHeight(currentRow, 8); currentRow++;
      
      // 배송/입금 정보
      statementSheet.getRange(`A${currentRow}`).setValue('배송방식');
      statementSheet.getRange(`B${currentRow}:C${currentRow}`).merge();
      statementSheet.getRange(`B${currentRow}`).setValue(sameDaySales[0][11]);
      statementSheet.getRange(`D${currentRow}`).setValue('입금상태');
      statementSheet.getRange(`E${currentRow}:G${currentRow}`).merge();
      
      let allPaid = sameDaySales.every(s => s[8] === '완료' || s[8] === '입금완료');
      let anyPaid = sameDaySales.some(s => s[8] === '완료' || s[8] === '입금완료' || s[8] === '부분입금');
      let paidStatus = allPaid ? '입금완료' : (anyPaid ? '부분입금' : '미입금');
      statementSheet.getRange(`E${currentRow}`).setValue(paidStatus)
        .setBackground(paidStatus==='입금완료'?'#D9EAD3':paidStatus==='부분입금'?'#FFF2CC':'#F4CCCC').setFontWeight('bold');
      currentRow++;
      
      statementSheet.getRange(`A${currentRow}`).setValue('공박스회수');
      statementSheet.getRange(`B${currentRow}:C${currentRow}`).merge();
      let boxStatus = sameDaySales.every(s => s[13]==='회수') ? '회수' : '미회수';
      statementSheet.getRange(`B${currentRow}`).setValue(boxStatus).setBackground(boxStatus==='회수'?'#D9EAD3':'#FFF2CC').setFontWeight('bold');
      statementSheet.getRange(`D${currentRow}`).setValue('당일 미수금');
      statementSheet.getRange(`E${currentRow}:G${currentRow}`).merge();
      statementSheet.getRange(`E${currentRow}`).setValue(dayReceivable.toLocaleString()+' 원')
        .setHorizontalAlignment('right').setFontWeight('bold').setFontColor(dayReceivable>0?'#CC0000':'#006600');
      
      const infoStartRow = currentRow - 1; currentRow++;
      statementSheet.getRange(`A${infoStartRow}:A${currentRow}`).setBackground('#F3F3F3').setFontWeight('bold').setHorizontalAlignment('center');
      statementSheet.getRange(`D${infoStartRow}:D${currentRow}`).setBackground('#F3F3F3').setFontWeight('bold').setHorizontalAlignment('center');
      statementSheet.getRange(`A${infoStartRow}:G${currentRow}`).setBorder(true,true,true,true,true,true,'#CCCCCC',SpreadsheetApp.BorderStyle.SOLID);
      currentRow++;
      
      statementSheet.setRowHeight(currentRow, 10); currentRow++;
      
      // 서명란
      statementSheet.getRange(`A${currentRow}:G${currentRow}`).merge();
      statementSheet.getRange(`A${currentRow}`).setValue('인수자 서명: ___________________       날짜: ____ 년 ____ 월 ____ 일')
        .setFontSize(11).setHorizontalAlignment('center').setVerticalAlignment('middle')
        .setBorder(true,true,true,true,false,false,'#000000',SpreadsheetApp.BorderStyle.SOLID);
      statementSheet.setRowHeight(currentRow, 40); currentRow++;
      statementSheet.setRowHeight(currentRow, 5); currentRow++;
      
      statementSheet.getRange(`A${currentRow}:G${currentRow}`).merge();
      statementSheet.getRange(`A${currentRow}`).setValue('※ 본 거래명세표는 세금계산서를 대신할 수 없습니다.')
        .setFontSize(9).setFontColor('#999999').setHorizontalAlignment('center');
      currentRow++;
      
      if (copy === 0) {
        statementSheet.setRowHeight(currentRow, 10); currentRow++;
        statementSheet.setRowHeight(currentRow, 10); currentRow++;
        statementSheet.getRange(`A${currentRow}:G${currentRow}`).merge();
        statementSheet.getRange(`A${currentRow}`).setValue('✂ ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 절취선 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ ✂')
          .setFontSize(9).setHorizontalAlignment('center').setFontColor('#CCCCCC')
          .setBorder(true,false,true,false,false,false,'#CCCCCC',SpreadsheetApp.BorderStyle.DASHED);
        currentRow++;
        statementSheet.setRowHeight(currentRow, 10); currentRow++;
        statementSheet.setRowHeight(currentRow, 10); currentRow++;
      }
    }
    
    return { success: true, message: '거래명세표가 생성되었습니다 (2부 인쇄용).',
      url: ss.getUrl() + '#gid=' + statementSheet.getSheetId() };
  } catch (error) { return { success: false, message: '명세표 생성 실패: ' + error.toString() }; }
}

function generateStatement(saleIndex) {
  try {
    const salesSheet = ss.getSheetByName(SHEETS.sales);
    const selectedSale = salesSheet.getRange(Number(saleIndex)+2, 1, 1, 14).getValues()[0];
    return generateStatementByDateAndCustomer(
      Utilities.formatDate(new Date(selectedSale[0]), 'GMT+9', 'yyyy-MM-dd'), selectedSale[1]
    );
  } catch (error) { return { success: false, message: '명세표 생성 실패: ' + error.toString() }; }
}

// ==========================================
// 입고 관리
// ==========================================

function getPurchases(params) {
  try {
    const sheet = ss.getSheetByName(SHEETS.purchases);
    const lastRow = sheet.getLastRow();
    if (lastRow < 2) return { success: true, data: [] };

    // ✅ 13열로 확장 (K=지급상태, L=지급액, M=미지급금)
    const colCount = Math.min(13, sheet.getLastColumn());
    let purchases = sheet.getRange(2, 1, lastRow-1, colCount).getValues().map((row, index) => ({
      index, date: row[0], supplier: row[1], item: row[2],
      quantity: Number(row[3])||0, price: Number(row[4])||0,
      supplyPrice: Number(row[5])||0, vat: Number(row[6])||0, total: Number(row[7])||0,
      note: row[8]||'', traceNumber: row[9]||'',
      paymentStatus: row[10]||'미지급',
      paidAmount: Number(row[11])||0,
      unpaid: Number(row[12]) !== undefined ? Number(row[12]) : Number(row[7])||0
    }));
    
    if (params.supplier) purchases = purchases.filter(p => p.supplier === params.supplier);
    if (params.startDate) purchases = purchases.filter(p => new Date(p.date) >= new Date(params.startDate));
    if (params.endDate) purchases = purchases.filter(p => new Date(p.date) <= new Date(params.endDate));
    return { success: true, data: purchases };
  } catch (error) { return { success: false, message: '입고 내역 조회 실패: ' + error.toString() }; }
}

function addPurchase(data) {
  try {
    const total = Number(data.total)||0;
    // ✅ 13열 저장 (K=지급상태, L=지급액, M=미지급금)
    ss.getSheetByName(SHEETS.purchases).appendRow([
      data.date||'', data.supplier||'', data.item||'',
      Number(data.quantity)||0, Number(data.price)||0,
      Number(data.supplyPrice)||0, Number(data.vat)||0, total,
      data.note||'', data.traceNumber||'',
      '미지급',  // K열: 지급상태
      0,         // L열: 지급액
      total      // M열: 미지급금
    ]);
    return { success: true, message: '입고가 등록되었습니다.' };
  } catch (error) { return { success: false, message: '입고 등록 실패: ' + error.toString() }; }
}

// ==========================================
// 지급 관리
// ==========================================

function getSupplierPayments(params) {
  try {
    const sheet = ss.getSheetByName(SHEETS.supplierPayments);
    const lastRow = sheet.getLastRow();
    if (lastRow < 2) return { success: true, data: [] };
    
    let payments = sheet.getRange(2, 1, lastRow-1, 5).getValues().map(row => ({
      date: row[0], supplier: row[1], amount: Number(row[2])||0, method: row[3]||'', note: row[4]||''
    }));
    if (params.supplier) payments = payments.filter(p => p.supplier === params.supplier);
    if (params.startDate) payments = payments.filter(p => new Date(p.date) >= new Date(params.startDate));
    if (params.endDate) payments = payments.filter(p => new Date(p.date) <= new Date(params.endDate));
    return { success: true, data: payments };
  } catch (error) { return { success: false, message: '지급 내역 조회 실패: ' + error.toString() }; }
}

function addSupplierPayment(data) {
  try {
    ss.getSheetByName(SHEETS.supplierPayments).appendRow([
      data.date||'', data.supplier||'', Number(data.amount)||0, data.method||'', data.note||''
    ]);
    updatePayables(data.supplier, Number(data.amount)||0);
    return { success: true, message: '지급이 등록되었습니다.' };
  } catch (error) { return { success: false, message: '지급 등록 실패: ' + error.toString() }; }
}

function updatePayables(supplier, paymentAmount) {
  const sheet = ss.getSheetByName(SHEETS.purchases);
  const lastRow = sheet.getLastRow();
  if (lastRow < 2) return;

  // ✅ 13열 읽기 (M열=미지급금이 13번째)
  const colCount = Math.min(13, sheet.getLastColumn());
  const data = sheet.getRange(2, 1, lastRow-1, colCount).getValues();
  let remaining = paymentAmount;

  for (let i = 0; i < data.length; i++) {
    // M열(index 12) = 미지급금
    const unpaid = Number(data[i][12]) || Number(data[i][7]) || 0;
    if (data[i][1] === supplier && unpaid > 0 && remaining > 0) {
      const ded = Math.min(unpaid, remaining);
      const newUnpaid = unpaid - ded;
      const newPaid = (Number(data[i][11])||0) + ded;

      sheet.getRange(i+2, 13).setValue(newUnpaid);  // M: 미지급금
      sheet.getRange(i+2, 12).setValue(newPaid);     // L: 지급액
      sheet.getRange(i+2, 11).setValue(             // K: 지급상태
        newUnpaid === 0 ? '지급완료' : '부분지급'
      );
      remaining -= ded;
    }
  }
}

// ==========================================
// 재고 관리
// ==========================================

function getInventory() {
  try {
    const purchaseSheet = ss.getSheetByName(SHEETS.purchases);
    const salesSheet = ss.getSheetByName(SHEETS.sales);
    const itemsSheet = ss.getSheetByName(SHEETS.items);
    const itemsLastRow = itemsSheet.getLastRow();
    if (itemsLastRow < 2) return { success: true, data: [] };
    
    const inventory = {};
    itemsSheet.getRange(2, 1, itemsLastRow-1, 4).getValues().forEach(row => {
      inventory[row[0]] = { item: row[0], unit: row[1]||'', inbound: 0, outbound: 0, stock: 0, avgCost: 0, value: 0 };
    });
    
    const purLastRow = purchaseSheet.getLastRow();
    if (purLastRow >= 2) {
      purchaseSheet.getRange(2, 1, purLastRow-1, 9).getValues().forEach(row => {
        const item = row[2], qty = Number(row[3])||0, price = Number(row[4])||0;
        if (inventory[item]) {
          const prev = inventory[item].inbound;
          inventory[item].inbound += qty;
          inventory[item].avgCost = inventory[item].inbound > 0
            ? (inventory[item].avgCost * prev + price * qty) / inventory[item].inbound : 0;
        }
      });
    }
    
    const salLastRow = salesSheet.getLastRow();
    if (salLastRow >= 2) {
      salesSheet.getRange(2, 1, salLastRow-1, 12).getValues().forEach(row => {
        if (inventory[row[2]]) inventory[row[2]].outbound += Number(row[3])||0;
      });
    }
    
    Object.keys(inventory).forEach(item => {
      inventory[item].stock = inventory[item].inbound - inventory[item].outbound;
      inventory[item].value = Math.round(inventory[item].stock * inventory[item].avgCost);
    });
    
    return { success: true, data: Object.values(inventory) };
  } catch (error) { return { success: false, message: '재고 조회 실패: ' + error.toString() }; }
}

// ==========================================
// 연간 월별 집계
// ==========================================

function getYearlyReport(year) {
  try {
    const salesSheet = ss.getSheetByName(SHEETS.sales);
    const purchaseSheet = ss.getSheetByName(SHEETS.purchases);
    const targetYear = Number(year) || new Date().getFullYear();

    // 12개월 초기화
    const months = [];
    for (let m = 1; m <= 12; m++) {
      months.push({
        month: m,
        taxSales: 0,        // 과세 공급가
        salesVat: 0,        // 매출 부가세
        exemptSales: 0,     // 면세 매출
        totalSales: 0,      // 총 매출
        totalPurchase: 0,   // 총 입고
        purchaseVat: 0,     // 입고 부가세
        profit: 0           // 순이익
      });
    }

    // 판매거래 집계
    const salLastRow = salesSheet.getLastRow();
    if (salLastRow >= 2) {
      salesSheet.getRange(2, 1, salLastRow-1, 15).getValues().forEach(row => {
        const d = new Date(row[0]);
        if (d.getFullYear() !== targetYear) return;
        const m = d.getMonth(); // 0-based
        const taxType = row[14] || '과세';
        const supplyPrice = Number(row[5]) || 0;  // 실제 공급가 합계
        const vat = Number(row[6]) || 0;           // 실제 부가세 합계
        const total = Number(row[7]) || 0;         // 실제 합계금액

        if (taxType === '면세') {
          months[m].exemptSales += total;
        } else {
          months[m].taxSales += supplyPrice;
          months[m].salesVat += vat;
        }
      });
    }

    // 입고거래 집계
    const purLastRow = purchaseSheet.getLastRow();
    if (purLastRow >= 2) {
      purchaseSheet.getRange(2, 1, purLastRow-1, 9).getValues().forEach(row => {
        const d = new Date(row[0]);
        if (d.getFullYear() !== targetYear) return;
        const m = d.getMonth();
        months[m].totalPurchase += Number(row[7]) || 0;
        months[m].purchaseVat += Number(row[6]) || 0;
      });
    }

    // 합계 계산
    let totals = { taxSales:0, salesVat:0, exemptSales:0, totalSales:0, totalPurchase:0, purchaseVat:0, profit:0 };

    months.forEach(m => {
      m.totalSales = m.taxSales + m.salesVat + m.exemptSales;
      m.profit = m.totalSales - m.totalPurchase;
      totals.taxSales += m.taxSales;
      totals.salesVat += m.salesVat;
      totals.exemptSales += m.exemptSales;
      totals.totalSales += m.totalSales;
      totals.totalPurchase += m.totalPurchase;
      totals.purchaseVat += m.purchaseVat;
      totals.profit += m.profit;
    });

    return { success: true, data: { year: targetYear, months, totals } };
  } catch (error) { return { success: false, message: '연간 집계 조회 실패: ' + error.toString() }; }
}



function getMonthlyReport(year, month) {
  try {
    const salesSheet = ss.getSheetByName(SHEETS.sales);
    const purchaseSheet = ss.getSheetByName(SHEETS.purchases);
    const targetYear = Number(year)||new Date().getFullYear();
    const targetMonth = Number(month)||(new Date().getMonth()+1);
    
    let sales = 0, cost = 0, receivables = 0;
    const salLastRow = salesSheet.getLastRow();
    if (salLastRow >= 2) {
      salesSheet.getRange(2, 1, salLastRow-1, 12).getValues().forEach(row => {
        const d = new Date(row[0]);
        if (d.getFullYear()===targetYear && (d.getMonth()+1)===targetMonth) {
          sales += Number(row[7])||0; receivables += Number(row[10])||0;
        }
      });
    }
    const purLastRow = purchaseSheet.getLastRow();
    if (purLastRow >= 2) {
      purchaseSheet.getRange(2, 1, purLastRow-1, 9).getValues().forEach(row => {
        const d = new Date(row[0]);
        if (d.getFullYear()===targetYear && (d.getMonth()+1)===targetMonth) cost += Number(row[7])||0;
      });
    }
    const profit = sales - cost;
    return { success: true, data: { year: targetYear, month: targetMonth, sales, cost, profit,
      profitMargin: sales>0?Math.round((profit/sales)*100):0, receivables }};
  } catch (error) { return { success: false, message: '월별 리포트 조회 실패: ' + error.toString() }; }
}

function getProfitLoss(startDate, endDate) {
  try {
    const salesSheet = ss.getSheetByName(SHEETS.sales);
    const purchaseSheet = ss.getSheetByName(SHEETS.purchases);
    const paymentsSheet = ss.getSheetByName(SHEETS.payments);
    let totalSales = 0, totalCost = 0, totalReceived = 0;
    
    const salLastRow = salesSheet.getLastRow();
    if (salLastRow >= 2) {
      salesSheet.getRange(2, 1, salLastRow-1, 12).getValues().forEach(row => {
        const d = new Date(row[0]);
        if ((!startDate||d>=new Date(startDate))&&(!endDate||d<=new Date(endDate))) totalSales += Number(row[7])||0;
      });
    }
    const purLastRow = purchaseSheet.getLastRow();
    if (purLastRow >= 2) {
      purchaseSheet.getRange(2, 1, purLastRow-1, 9).getValues().forEach(row => {
        const d = new Date(row[0]);
        if ((!startDate||d>=new Date(startDate))&&(!endDate||d<=new Date(endDate))) totalCost += Number(row[7])||0;
      });
    }
    const payLastRow = paymentsSheet.getLastRow();
    if (payLastRow >= 2) {
      paymentsSheet.getRange(2, 1, payLastRow-1, 5).getValues().forEach(row => {
        const d = new Date(row[0]);
        if ((!startDate||d>=new Date(startDate))&&(!endDate||d<=new Date(endDate))) totalReceived += Number(row[2])||0;
      });
    }
    const grossProfit = totalSales - totalCost;
    return { success: true, data: { startDate: startDate||'', endDate: endDate||'',
      revenue: totalSales, cost: totalCost, grossProfit,
      grossMargin: totalSales>0?Math.round((grossProfit/totalSales)*100):0, cashReceived: totalReceived }};
  } catch (error) { return { success: false, message: '손익계산 실패: ' + error.toString() }; }
}

// ==========================================
// 대시보드
// ==========================================

function getDashboard() {
  try {
    const monthlyReport = getMonthlyReport(new Date().getFullYear(), new Date().getMonth()+1);
    const inventoryResult = getInventory();
    const lowStockItems = inventoryResult.success && inventoryResult.data
      ? inventoryResult.data.filter(item => item.stock <= 5 && item.stock >= 0).length : 0;
    
    if (monthlyReport.success) {
      return { success: true, data: {
        monthlySales: monthlyReport.data.sales, monthlyProfit: monthlyReport.data.profit,
        totalReceivables: monthlyReport.data.receivables, lowStockItems
      }};
    }
    return { success: true, data: { monthlySales:0, monthlyProfit:0, totalReceivables:0, lowStockItems }};
  } catch (error) { return { success: false, message: '대시보드 조회 실패: ' + error.toString() }; }
}
